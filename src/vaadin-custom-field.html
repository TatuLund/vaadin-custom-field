<!--
@license
Copyright (c) 2018 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="../../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../../vaadin-element-mixin/vaadin-element-mixin.html">

<dom-module id="vaadin-custom-field">
  <template>
    <style>
      :host {
        display: inline-block;
      }

      :host([hidden]) {
        display: none !important;
      }

      .container {
        display: flex;
        flex-direction: column;
      }

      .inputs-wrapper {
        display: block;
        flex: 1;
      }
    </style>

    <div class="container">
      <label part="label" on-click="focus" id="[[__labelId]]">[[label]]</label>
      <div class="inputs-wrapper">
        <slot id="slot"></slot>
      </div>
      <div part="error-message"
          id="[[__errorId]]"
          aria-live="assertive"
          aria-hidden$="[[__getErrorMessageAriaHidden(invalid, errorMessage, __errorId)]]"
        >[[errorMessage]]</div>
    </div>

  </template>

  <script>
    (function() {

      /**
       * `<vaadin-custom-field>` is a Web Component.
       *
       * ```
       * <vaadin-custom-field></vaadin-custom-field>
       * ```
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */
      class CustomFieldElement extends Vaadin.ElementMixin(Vaadin.ThemableMixin(Polymer.Element)) {
        static get is() {
          return 'vaadin-custom-field';
        }
        static get version() {
          return '0.1.0';
        }

        static get properties() {
          return {
            /*
             * Array of available input nodes
             */
            __inputs: Array,

            i18n: {
              type: Object,
              value: () => {
                return {
                  setValue: (value, nodes) => {
                    const splittedValues = value.split(' ');
                    return nodes.forEach((el, id) => el.value = splittedValues[id]);
                  },
                  formatValue: inputValues => inputValues.join(' ')
                };
              }
            },

            /**
             * String used for the label element.
             */
            label: {
              type: String,
              value: '',
              observer: '_labelChanged'
            },

            /**
             * The name of the control, which is submitted with the form data.
             */
            name: String,

            /**
             * Specifies that the user must fill in a value.
             */
            required: {
              type: Boolean,
              reflectToAttribute: true
            },

            /**
             * The initial value of the control.
             * It can be used for two-way data binding.
             */
            value: {
              type: String,
              observer: '__valueChanged',
              notify: true
            },

            /**
             * This property is set to true when the control value is invalid.
             */
            invalid: {
              type: Boolean,
              reflectToAttribute: true,
              notify: true,
              value: false,
              observer: '__invalidChanged'
            },

            /**
             * Error to show when the input value is invalid.
             */
            errorMessage: {
              type: String,
              value: ''
            },

            __errorId: String,
            __labelId: String
          };
        }

        static get observers() {
          return [
            '__getActiveErrorId(invalid, errorMessage, __errorId)',
            '__getActiveLabelId(label, __labelId)',
            '__updateRequired(required, __inputs)'
          ];
        }

        ready() {
          super.ready();

          this.$.slot.addEventListener('slotchange', e =>
            this.__setInputs(e.target.assignedNodes().filter(node => node.validate || node.checkValidity)));

          var uniqueId = Vaadin.CustomFieldElement._uniqueId = 1 + Vaadin.CustomFieldElement._uniqueId || 0;
          this.__errorId = `${this.constructor.is}-error-${uniqueId}`;
          this.__labelId = `${this.constructor.is}-label-${uniqueId}`;
        }

        __updateValue(e) {
          // Stop native change events
          e && e.stopPropagation();

          this.validate();
          this.value = this.i18n.formatValue.apply(this, [this.inputs.map(input => input.value)]);
          this.dispatchEvent(new CustomEvent('change', {
            bubbles: true,
            cancelable: false,
            detail: {
              value: this.value
            }
          }));
        }

        __invalidChanged(invalid) {
          this.__setOrToggleAttribute('aria-invalid', invalid, this);
        }

        __valueChanged(value) {
          this.i18n.setValue(value, this.inputs);
          this.validate();
        }

        __setInputs(nodes) {
          this.__inputs = nodes;
          this.inputs.forEach(input => input.addEventListener('change', e => this.__updateValue(e)));
          this.validate();
        }

        __updateRequired(required, inputs) {
          if (!inputs) {
            return;
          }

          if (required) {
            inputs.forEach(input => input.setAttribute('required', ''));
          } else {
            inputs.forEach(input => input.removeAttribute('required'));
          }
        }

        _labelChanged(label) {
          if (label !== '' && label != null) {
            this.setAttribute('has-label', '');
          } else {
            this.removeAttribute('has-label');
          }
        }

        /**
         * Returns true if `value` is valid.
         * `<iron-form>` uses this to check the validity or all its elements.
         *
         * @return {boolean} True if the value is valid.
         */
        validate() {
          return !(this.invalid = !this.checkValidity());
        }

        /**
         * Returns true if the current inputs values satisfy all constraints (if any)
         * @returns {boolean}
         */
        checkValidity() {
          if (this.required) {
            return this.inputs.every(input => (input.validate || input.checkValidity).call(input));
          } else {
            return !this.invalid;
          }
        }

        __setOrToggleAttribute(name, value, node) {
          if (!name || !node) {
            return;
          }
          if (node.hasAttribute(name) === !value) {
            if (value) {
              node.setAttribute(name, (typeof value === 'boolean') ? '' : value);
            } else {
              node.removeAttribute(name);
            }
          }
        }

        __getActiveErrorId(invalid, errorMessage, errorId) {
          this.__setOrToggleAttribute('aria-describedby',
            (errorMessage && invalid ? errorId : undefined),
            this);
        }

        __getActiveLabelId(label, labelId) {
          this.__setOrToggleAttribute('aria-labelledby',
            (label ? labelId : undefined),
            this);
        }

        __getErrorMessageAriaHidden(invalid, errorMessage, errorId) {
          return (!(errorMessage && invalid ? errorId : undefined)).toString();
        }

        get inputs() {
          return this.__inputs;
        }
      }

      customElements.define(CustomFieldElement.is, CustomFieldElement);

      /**
       * @namespace Vaadin
       */
      window.Vaadin.CustomFieldElement = CustomFieldElement;
    })();
  </script>
</dom-module>
